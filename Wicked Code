#include <stdio.h>

#include <pthread.h>
#include <time.h>
#include <string.h>

//sudo gcc -Wall

//Initialization methods.
extern "C" int init_hardware();
extern "C" int init(int d_lev);

//Camera methods.
extern "C" int take_picture();
extern "C" char get_pixel(int row, int col, int color);
extern "C" void set_pixel(int col, int row, char red, char green, char blue);

//Motor method.
extern "C" int set_motor(int motor,int speed);

//Utility methods.
extern "C" int read_analog(int ch_adc);
extern "C" int Sleep(int sec, int usec);
extern "C" int select_IO(int chan, int direct);
extern "C" int write_digital(int chan, char level);
extern "C" int read_digital(int chan);
extern "C" int set_PWM(int chan, int value);

//Server methods.
extern "C" int connect_to_server(char server_addr[15], int port);
extern "C" int send_to_server(char message[24]);
extern "C" int receive_from_server(char message[24]);

//Constant variables.
int speed = 40;
int turn_sharpness = 100;

//Function declarations.
float locate_line();

int main(){

    //Initialize.
    init(0);

    //Set speed to zero at start.
    set_motor(1, 0);
    set_motor(2, 0);

    float proportional_error;

    //while 'true' loop makes the robot repeat what it's doing, could put a condition which tells the robots it's finished in here.
    while(true){

        /*
        Use the locate_line method to locate the line.
        Then use the follow_line method to decide what to do.
        */
        proportional_error = locate_line(); //Find the proportional error of the line by using the locate_line method.

        //Make sure the locate line method is returning a legitimate value.
        if (proportional_error > 1 || proportional_error < -1){
            return 0;
        }

        //Turn the robot.
        set_motor(1, speed - (proportional_error * turn_sharpness));
        set_motor(2, speed + (proportional_error * turn_sharpness));

        /*
        The left motor should be in port 1, and the right motor in port 2.

        A negative average indicates the robot has to turn left,
        a positive average indicate the robot has to turn right.

        This means we decrease the speed of the left wheel on negative averages, and vice versa for positive.
        This gives the added benefit of slowing down for sharp corners.
        */

    }

    //Stop robot once done.
    set_motor(1, 0);
    set_motor(2, 0);

    return 0;

}

/*
This method takes a picture, and uses the brightness of each of the pixels to determine where the line is.
The error will be returned in the range -1 to +1.
*/
float locate_line(){

    int row = 160;

    //Declare arrays.
    float brightness_list[ 320 ];
    float weight[ 320 ];

    //Declare color variables for use in the first loop.
    char brightness;

    //declare maths variables for use in the second loop.
    float sum = 0;
    float number = 0;
    float average = 0;

    //Declares loop increment variables.
    int i = 0;
    int j = 0;

    take_picture(); //Takes a picture and stores in memory.

    /*
    This loop takes information about the picture and creates two arrays.

    The brightness array is given a 1 or 0 value for each pixel based on whether the robot thinks it's looking at line or not.
    The weight array simply has numbers ranging from -159.5 to +159.5 for each pixel.
    */
    for(i = 0; i < 320; i++){

        //Find the brightness of a pixel in appropriate row.
        brightness = get_pixel(row, i + 1, 3);

        //Puts a brightness value of 1 or 0 into the brightness array, based on whether the pixel is more or less bright than the average.
        if(brightness > 127){

            brightness_list[ i ] = 1; //Set value at position 'i' to 1 (meaning that it's bright).

        }else{

            brightness_list[ i ] = 0; //Set value at position 'i' to 0 (meaning that it's not bright).

        }

        /*
        Puts appropriate weight value in 'i' position of weight array.
        The range starts at 0 - 319.
        159.5 is divided leaving a range of 0 - 2.
        Then this range is subtracted by 1, leaving a useful range of +1 to -1.
        */
        weight[ i ] = (i/159.5) - 1;

    }

    /*
    This loop sums the weights of the bright pixels,
    then finds an average by dividing by the number of bright pixels.

    A negative average indicates the robot has to turn left,
    a positive average indicate the robot has to turn right.
    */
    for(j = 0; j < 320; j++){

        sum = sum + brightness_list[ j ] * weight[ j ]; //Adds a pixels weight to a sum if the loop before said it was a bright one.
        number++; //Adds one to the number of values taken so we can calculate the average later.

    }

    average = sum / number; //Calculates the average of the weighted brightness values.
    return average; //Returns the average for the locate_line method.

    /*
    The average is taken from values ranging from -1 to +1,
    so the average must also be in this range.
    */

}
