#include <stdio.h>

#include <pthread.h>
#include <time.h>
#include <string.h>

//sudo gcc -Wall

//Initialization methods.
extern "C" int init_hardware();
extern "C" int init(int d_lev);

//Camera methods.
extern "C" int take_picture();
extern "C" char get_pixel(int row, int col, int color);
extern "C" void set_pixel(int col, int row, char red, char green, char blue);

//Motor method.
extern "C" int set_motor(int motor,int speed);

//Utility methods.
extern "C" int read_analog(int ch_adc);
extern "C" int Sleep(int sec, int usec);
extern "C" int select_IO(int chan, int direct);
extern "C" int write_digital(int chan, char level);
extern "C" int read_digital(int chan);
extern "C" int set_PWM(int chan, int value);

//Server methods.
extern "C" int connect_to_server(char server_addr[15], int port);
extern "C" int send_to_server(char message[24]);
extern "C" int receive_from_server(char message[24]);

//Constant variables.
int speed = 40;
int turn_sharpness = 100;

//Function declarations.
float locate_line();

int main(){

    //Initialize.
    init(0);

    //Set speed to zero at start.
    set_motor(1, 0);
    set_motor(2, 0);

    float proportional_error;

    //while 'true' loop makes the robot repeat what it's doing, could put a condition which tells the robots it's finished in here.
    while(true){

        /*
        Use the locate_line method to locate the line.
        Then use the follow_line method to decide what to do.
        */
        proportional_error = locate_line(160); //Find the proportional error of the line by using the locate_line method. Parameter is the row of the image to use.

        //Make sure the locate line method is returning a legitimate value.
        if (proportional_error > 1 || proportional_error < -1){
            printf("Exception - Locate line function failed.")
            return 0;
        }

        //Turn the robot.
        set_motor(1, speed - (proportional_error * turn_sharpness));
        set_motor(2, speed + (proportional_error * turn_sharpness));

        /*
        The left motor should be in port 1, and the right motor in port 2.

        A negative average indicates the robot has to turn left,
        a positive average indicate the robot has to turn right.

        This means we decrease the speed of the left wheel on negative averages, and vice versa for positive.
        This gives the added benefit of slowing down for sharp corners.
        */

    }

    //Stop robot once done.
    set_motor(1, 0);
    set_motor(2, 0);

    return 0;

}

/*
This method takes a picture, and uses the luminosity of each of the pixels to determine where the line is.
The error will be returned in the range -1 to +1.
*/
float locate_line(int row){

    //Declare color variables for use in the first loop.
    char luminosity;

    //declare maths variables for use later.
    float weight_sum = 0;
    float number = 0;
    float weight_average = 0;

    take_picture(); //Takes a picture and stores in memory.

    /*
    The loop below sums the weights of the bright pixels,
    then finds an average by dividing by the number of bright pixels.

    A negative average indicates the robot has to turn left,
    a positive average indicate the robot has to turn right.
    */
    for(int i = 0; i < 320; i++){

        //Find the luminosity of a pixel in appropriate row.
        luminosity = get_pixel(row, i + 1, 3);

        /*
        Sets appropriate weight value.
        The range of weight values starts at 0 - 319.
        159.5 is divided leaving a range of 0 - 2.
        Then this range is subtracted by 1, leaving a useful range of +1 to -1.
        */
        weight = (i/159.5) - 1;

        //Adds the pixels weight to the weight_sum if the pixel is bright enough.
        if(luminosity > 127){

            weight_sum = weight_sum + weight;
            number++;

        }

    }

    weight_average = weight_sum / number; //Calculates the average of the weighted luminosity values.
    return weight_average; //Returns the average for the locate_line method.

    /*
    The average is taken from values ranging from -1 to +1,
    so the average must also be in this range.
    */

}
